Programmierung in C
Für den Zugriff auf das Expander-Board wurde eine einfache Library, bestehend aus C- und Headerdatei erstellt. In der Headerdatei wird zuerst abgefragt, ob der Name des Headers bereits existiert. Wenn nein, wird der Inhalt der Headerdatei eingesetzt. Andernfalls springt der Präprozessor direkt zum Ende der Headerdatei. Es kann nämlich vorkommen, dass eine Headerdatei mehrfach eingebunden wird (mehrere Include-Anweisungen in verschiedenen Quelldateien). Durch dieses Standardkonstrukt werden Duplikate (und damit Compiler-Fehlermeldungen) vermieden.

In der Headerdatei (Endung ".h") werden alle Konstanten, globale Variablen und Funktionsprototypen der Bibliothek aufgeführt. Das folgende Listign dient auch gleichzeitig als Dokumentation der Funktionen. Für den Expander-Datentyp wurde eine Struktur entworfen, die alle wichtigen Informationen aufnimmt, die I2C-Bus-Adresse des Bausteines, die Datenrichtung für bei de Ports und den Devicenamen des I2C-Device ("/dev/i2c-1" für Bus 1). Diese Struktur wird von allen Funktionen verwendet.

#ifndef _EXPANDERLIB_H_
#define _EXPANDERLIB_H_

/* Richtungsregister von Port A und Port B */
#define IODIRA 0x00
#define IODIRB 0x01

/* Datenregister Port A und Port B */
#define GPIOA 0x12
#define GPIOB 0x13

/* Register um Logik-Polaritaet umzustellen */
#define IPOLA 0x02
#define IPOLB 0x03

/* Interne Pull-Up-Widerstände einschalten */
#define GPPUA 0x0C
#define GPPUB 0x0D

/* Pins am Port */
#define P1 0x01
#define P2 0x02
#define P3 0x04
#define P4 0x08
#define P5 0x10
#define P6 0x20
#define P7 0x40
#define P8 0x80


/* Struktur fuer den Expander-Datentyp */
struct expander
  {
  int address;      /* I2C-Bus-Adresse des Bausteines      */
  int directionA;   /* Datenrichtung Port A                */
  int directionB;   /* Datenrichtung Port B                */
  char* I2CBus;     /* I2C-Device ("/dev/i2c-1" für Bus 1) */
  };
/* Expander-Datentyp */
typedef struct expander mcp23017;

/* Init des Expanders; gibt den Expander zurück
 * address: I2C-Busadresse des Bausteines (i2cdetect -y 1)
 * directionA/B: Richtungen der Ports
 * I2CBus: Pfad zum I2CBus ("/dev/i2c-1" für Bus 1)
 */
mcp23017 init_mcp23017(int address, int directionA, int directionB, char* I2CBus);

/* Datenrichtung der Ports festlegen
 * richtungsregister: muss "IODIRA" oder "IODIRB" sein!
 * value: Zuordnung der Bits (Input: 1, Output: 0)
 * Bei den Eingangspins wird der Pullup-Widerstand eingeschaltet und die Logik umgekehrt
 */
void setdir_mcp23017(mcp23017 expander, int richtungsregister, int value);

/* Oeffnet den Bus und gibt Filedescriptor zurueck
 * (write_mcp23017 und read_mcp23017 übernehmen das selbst)
 */
int open_mcp23017(mcp23017 expander);

/* Schreibt in ein Register des Expanders
 * reg: Register in das geschrieben werden soll
 * value: Byte das geschrieben werden soll
 */
void write_mcp23017(mcp23017 expander, int reg, int value);

/* Liest Register des Expanders
 * reg: Register, das ausgelesen wird;
 * gibt ausgelesenen Registerwert zurück
 */
int read_mcp23017(mcp23017 expander, int reg);

#endif /* EXPANDERLIB_H */
Der Code dazu befindet sich in einer C-Quelldatei gleichen Namens (Endung ".c"). Diese kann einfach beim Compilieren des eigentlichen Programms mit angegeben werden (siehe unten). Es ist aber auch möglich, eine Objectdatei zu erzeugen (Endung ".o"), die dann zum erzeugten Binärcode des eigentlichen Programms hinzugelinkt werden kann.

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


#include "expander_lib.h"

/* defined in <linux/i2c-dev.h>
#define I2C_SLAVE 0x703 */


/* Init des Expanders; gibt den Expander zurück
 * address: I2C-Busadresse des Bausteines (i2cdetect -y 1)
 * directionA/B: Richtungen der Ports
 * I2CBus: Pfad zum I2CBus ("/dev/i2c-1" für Bus 1)
 */
mcp23017 init_mcp23017(int address, int directionA, int directionB, char* I2CBus)
  {
  int fd;             /* Filehandle */
  mcp23017 expander;  /* Rueckgabedaten */

  /* Structure mit Daten fuellen */
  expander.address = address;
  expander.directionA = directionA;
  expander.directionB = directionB;
  expander.I2CBus = I2CBus;

  // Port-Richtung (Eingabe/Ausgabe) setzen
  fd = open_mcp23017(expander);
  setdir_mcp23017(expander, IODIRA, expander.directionA);
  setdir_mcp23017(expander, IODIRB, expander.directionB);
  close(fd);
  return expander;
  }

/* Datenrichtung der Ports festlegen
 * richtungsregister: muss "IODIRA" oder "IODIRB" sein!
 * value: Zuordnung der Bits (Input: 1, Output: 0)
 * Bei den Eingangspins wird der Pullup-Widerstand eingeschaltet und die Logik umgekehrt
 */
void setdir_mcp23017(mcp23017 expander, int richtungsregister, int value)
  {
  if(richtungsregister == IODIRA)
    {
    /* Datenrichtung schreiben */
    write_mcp23017(expander, IODIRA, value);
    /* Pull-Up-Widerstaende einschalten Port A */
    write_mcp23017(expander, GPPUA, value);
    /* Logik umkehren */
    write_mcp23017(expander, IPOLA, value);
    }
  else if(richtungsregister == IODIRB)
    {
    /* Datenrichtung schreiben */
    write_mcp23017(expander, IODIRB, value);
    /* Pull-Up-Widerstaende einschalten Port B */
    write_mcp23017(expander, GPPUB, value);
    /*Logik umkehren */
    write_mcp23017(expander, IPOLB, value);
    }
  else
    {
    printf("Richtungsregister falsch!\n");
    exit(1);
    }
  }

/* Oeffnet den Bus und gibt Filedescriptor zurueck
 * (write_mcp23017 und read_mcp23017 übernehmen das selbst)
 */
int open_mcp23017(mcp23017 expander)
  {
  int fd;
  if ((fd = open(expander.I2CBus, O_RDWR)) < 0)
    {
    printf("Failed to open the i2c bus\n");
    exit(1);
    }

  /* Spezifizieren der Adresse des slave device */
  if (ioctl(fd, I2C_SLAVE, expander.address) < 0)
    {
    printf("Failed to acquire bus access and/or talk to slave\n");
    exit(1);
    }
  return fd;
  }

/* Schreibt in ein Register des Expanders
 * reg: Register in das geschrieben werden soll
 * value: Byte das geschrieben werden soll
 */
void write_mcp23017(mcp23017 expander, int reg, int value)
  {
  int fd;
  fd = open_mcp23017(expander);
  if(i2c_smbus_write_byte_data(fd,reg,value) < 0)
    {
    printf("Failed to write to the i2c bus\n");
    exit(1);
    }
  close(fd);
  }

/* Liest Register des Expanders
 * reg: Register, das ausgelesen wird;
 * gibt ausgelesenen Registerwert zurück
 */
int read_mcp23017(mcp23017 expander, int reg)
   {
   int value,fd;
   fd = open_mcp23017(expander);
   if((value = i2c_smbus_read_byte_data(fd, reg)) < 0)
     {
     printf("Failed to read from the i2c bus\n");
     close(fd);
     exit(1);
     return 0;
     }
   else
     {
     close(fd);
     return value;
     }
  }
Wenn es so einfach ist wie hier, wo nur zwei C-Quellen angegeben werden müssen, muss kein Makefile und keine Objectdatei erzeugt werden, es genügt ein einfacher Compileraufruf:
gcc -Wall -o lauflicht lauflicht.c expander_lib.c
Das Lauflicht selbst bedarf an sich keiner Beschreibung mehr. Man kennt es aus der Fernsehserie der 80er Jahre, wo ein Auto die Hauptrolle spielte (und ein Sänger die Nebenrolle). Das Programm soll nur zeigen, wie die oben aufgeführte Bibliothek eingebunden werden kann:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "expander_lib.h"

int main(int argc, char *argv[])
  {
  mcp23017 expander;  /* Verwaltungs-Structure */
  int data = 0x01;    /* Ausgabewert */
  int down = 0;       /* Richtungsangabe */

  expander = init_mcp23017(0x20,0,0,"/dev/i2c-1");

  while(1)
    {
    /* beide Ports identisch "bedienen" */
    write_mcp23017(expander,GPIOA,data);
    write_mcp23017(expander,GPIOB,data);

    if (data == 0x80) /* ganz links - umdrehen */
      down = 1;
    if (data == 0x01) /* ganz rechts - umdrehen */
      down = 0;

    if (down)
       data = data >> 1;
    else
       data = data << 1;
    usleep(100000); /* 100 ms Pause */
    }

  return 0;
  }
Sollen anstelle der LEDs gleich größere Lasten, beispielsweise Relais, geschaltet werden, könnte man das Layout des Boards ändern uns statt der LED-Treiber Bausteine des Typs ULN2803 einsetzen, die dann bis zu 0,5 A schalten können. Man kann aber auch eine fertige Relaiskarte (z. B. den Pollin-Bausatz "PC-Relaiskarte K8IO", Bestellnummer: 710722, 12,95 Euro) an das Expander-Board anschließen.

Programmierung in C mit WiringPi
Bei WiringPi gibt es nicht nur eine Bibliothek für den I2C-Bus, sondern auch für den MCP23017. Sie müssen nur die beiden folgenden Includes in Ihr Programm aufnehmen:

#include <wiringPi.h>
#include <mcp23017.h>
Die Initialisierung erfolgt am Programmanfang durch:
wiringPiSetup();
mcp23017Setup(int pinBase, int i2cAddress);
Der Wert der Variablen pinBase kann eine beliebige Zahl größer 64 sein und die I2C-Adresse (i2cAddress) ist die Adresse des MCP23017 auf dem Bus (in der Regel 0x20, je nach Adresseinstellung). Wenn Sie beispielsweise die pinBase = 100 setzen, dann entsprechen im Programm die Pins 100 bis 107 dem Bits 0 bis 7 von Port A und die Pins 108 bis 115 den Bits 0 bis 7 von Port B.
Das folgende Programm gibt eine 8-Bit-Binärzahl aus und pausiert, wenn die Taste am MSB von Port B gedrückt wird. Die ersten 8 Pins sind als Ausgänge konfiguriert und der letzte ist ein Eingang mit aktiviertem internen Pull-up-Widerstand (die Taste schliesst gegen Masse).

#include <stdio.h>
#include <wiringPi.h>
#include <mcp23017.h>

/* Pin-Base */
#define BASE 100

/* Baustein-Adresse */
#define I2CADDR 0x20

int main (void)
  {
  int i, bit;

  wiringPiSetup();
  mcp23017Setup (BASE, I2CADDR);

  /* Ausgabepins definieren */
  for (i = 0; i < 8; ++i)
    pinMode (BASE + i, OUTPUT);

  /* Eingangspin definieren */
  pinMode         (BASE + 15, INPUT);
  pullUpDnControl (BASE + 15, PUD_UP);

  /* Endlosschleife */
  for (;;)
    {
    /* Ausgabe 8 Bit */
    for (bit = 0; bit < 8; ++bit)
      digitalWrite (BASE + bit, (1 << bit));
    delay (1);
    while (digitalRead (BASE + 15) == 0)
      /* Taste gedrueckt */
      delay (1);
    }
  return 0;
  }
